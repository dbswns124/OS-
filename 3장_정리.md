# 3장 프로세스

- - -
## 이 장의 목표
* 프로세스의 개별 구성요소를 식별하고 OS에서 해당 구성요소가 어떻게 표현되고 스케쥴되는지 기술
* OS에서 proc을 생성/종료하는 방법을 설명
* 공유 메모리 및 메시지 전달을 사용하는 IPC 통신을 설명하고 대조
* 파이프와 POSIX 공유 메모리를 사용하여 IPC를 수행하는 수행하는 프로그램을 설계
* 소켓과 원격 프로시져 호출을 사용하여 클라이언트-서버 통신을 설명
* Linux OS와 상호작용하는 kernel 모듈을 설계

- - -

## 3.1 프로세스 개념
OS를 논의할 떄 한가지 문제점이, 모든 CPU 활동들을 어떻게 부를 것인가에 대한 의문이었다.
초창기에는 job을 실행하는 일괄처리 시스템이었고, 사용자 프로그램 또는 task를 실행하는 시분할 시스템이 뒤를 이었다.
이제는 여러 프로그램을 한번에 실행할 수 있고 다중 태스킹을 지원하지 않는 ES 장치에서와 같은 곳에서도 OS는 
메모리 관리와 같은 자체 프로그램된 내부 활동을 지원해야 할 수도 있다.
따라서 이러한 모든 활동은 process라고 부를 수 있다.

 ### 3.1.1. 프로세스
 프로세스는 실행중인 프로그램이다. ( 프로그램 != 프로세스 )
 proc의 현재 활동 상태는 PC(다음에 실행할 명령어) + register의 내용으로 나타난다.

 <img width="184" alt="3장_1" src="https://github.com/dbswns124/OS-/assets/149889867/1219ffaf-9d6a-42dd-a4ea-6e70fddb2143">

proc의 메모리 내에서의 배치는 위와 같은 모양이다.
* 텍스트 : 실행 코드
* 데이터 섹션 : 전역 변수 ( C에서는 또다시 초기화 된 부분 / 초기화 되지 않은 부분 ( bss) 로 나뉜다 )
* 힙 : 프로그램 실행중에 동적으로 할당되는 메모리, 위로 자람
* 스택 : 함수를 호출할 때 임시 데이터 저장소, 아래로 자람 ( 함수 매개변수, 복귀 주소, 지역 변수 다 여기있음)

텍스트, 데이터 섹션의 크기는 불변이고, 힙과 스택은 가변적이다.

### 3.1.2 프로세스 상태 

<img width="377" alt="3장_2" src="https://github.com/dbswns124/OS-/assets/149889867/182856bc-99ef-40a6-90b2-6daec19918ce">
 
프로세스 상태 : 5 state ( 실행되면서 상태가 이 안에서 변함 )
new / running / waiting / ready / terminated
new proc은 ready queue로 감
프로세스는 실행을 위해 선택되거나 dispatch될 때까지 기다림
이름은 임의적이고, OS마다 다름, 하지만 모든 시스템에서 이 상태에 해당되는 단계들이 있음

### 3.1.3 프로세스 제어 블록 ( PCB )

각 프로세스는 PCB에 의해 표현된다.
특정 proc과 관련된 여러가지 정보들을 수록하며, 다음과 같은 정보들을 저장
process state(5 state)
PC : program counter, 다음에 실행할 명령어의 주소
CPU 레지스터들안의 값들
CPU 스케쥴링 정보 ( 우선순위, 스케쥴 큐에 대한 포인터 + 다른 스케쥴 매개변수들 )
메모리 관리정보(9장 참조)
회계정보 ( CPU 사용시간 + 경과된 실시간, 시간제한 .job/proc num도 포함됨)
입출력 상태정보 : 이 proc에 할당된 입출력 장치들과 열린파일 목록들(open file table)


### 3.1.4 스레드 ( threads )
이제까지 논의한 프로세스 모델은 프로세스가 단일 실행 스레드만 가능 == 한개의 논리적 흐름을 갖고 있음
대부분의 현대 OS는 프로세스 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용
따라서 한 프로세스의 여러 스레드가 병렬로 수행될 수 있게 된다.

## 3.2 프로세스 스케쥴링

멀티 프로그래밍 : CPU 이용률을 최대화 하는것에 목표가 있음, 따라서 메모리에 여러가지 프로그램을 올려서 그중 하나의 프로그램을 실행하는 것
이렇게 되면 여러 프로그램중에서 어느것을 실행해야 할지 결정해야 한다 -> 프로세스 스케쥴링이 필요해짐

### 3.2.1 스케쥴링 큐
프로세스가 시스템에 들어가면 ready queue에 들어가서 CPU 코어에서 실행되기를 기다리고, 일반적으로는 연결 리스트로 저장된다.

### 3.2.2 CPU 스케쥴링
프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 옮겨 다닌다.
**CPU 스케쥴러**의 역할은 준비 큐에 있는 proc중 선택된 하나의 proc에 CPU 코어를 할당하는 것이다.
( 일부 OS는 스와핑이라는 중간 형태의 스케쥴링을 이용, swap-in,out을 통해 다중 프로그래밍 정도를 낮춤 )

### 3.2.3 문맥 교환 ( context switch )
더이상 프로세스를 진행할 수 없어서 wait상태로 가거나, 인터럽트가 발생한 경우 등등에는 문맥을 저장하고 대기 상태로 간 후에 이벤트가 처리된 후에 재개 되어야 된다.
이 문맥은 PCB에 저장되고, 해댱되는 값은 레지스터 값, 프로세스 상태, 메모리 관리 정보 등을 포함한다.
CPU 코어를 다른 프로세스로 교환하려면
1. 현재 process의 정보를 PCB에 저장
2. 스케쥴링 알고리즘 돌려서 ready queue에서 한개의 process를 선택
3. 해당 process의 PCB에서 정보들을 덮어 씀
context switch동안에는 CPU가 유용한 일을 하지 못하기 때문에 이 시간은 순수한 오버헤드이다.

## 3.3 프로세스에 대한 연산
대부분 시스템 내의 프로세스들은 concurrent하게 실행될 수 있으며, 반드시 동적으로 생성되고 제거되어야 함

### 3.3.1 프로세스 생성
실행되는 동안 프로세스는 여러 개의 새로운 프로세스들을 생성할 수 있음 ( 리눅스에서는 fork() )
생성하는 proc = 부모 프로세스, 생성된 proc = 자식 프로세스
그리고 생성된 후에는 두가지 중에 한가지 형태를 보인다
1. 부모와 자식이 병행하게 실행을 계속
2. 부모는 일부 또는 모든 자식이 실행을 종료할 때 까지 기다린다.
따라서 시스템은 프로레스 트리를 형성할 수 있다.
대부분의 현대 OS는 **유일한** 프로세스 식별자(pid)를 사용하여 프로세스를 구분하는데, 이 식별자는 보통 정수다.

### 3.3.2 프로세스 종료
프로세스가 마지막 문장의 실행을 끝내고 exit() 시스템 콜을 사용하여 OS에 자신의 삭제를 요청하면 종료된다.
이 시점에서 프로세스는 자신을 기다리고 있는 부모 프로세스에 종료상태값을 반환할 수 있다.
종료시에는 갖고있던 모든 자원이 할당 해제되고 OS로 반납된다
아니면 한 프로세스는 다른 프로세스에 의해 종료될 수도 있다. ( kill(pid)를 통해 )

> 좀비 프로세스 : 종료되었지만, 부모 프로세스가 아직 wiat() 호출을 하지 않은 프로세스
>              -> 종료 상태가 저장되는 프로세스 테이블의 항목은 남아있게 됨
> 고아 프로세스 : 부모 프로세스가 wait()을 호출하는 대신 종료하면 이 상황에 부닥친 프로세스를 고아 프로세스                 라고 함
> 전통적인 INIX는 고아 프로세스의 새로운 프로세스를 init 프로세스로 지정 + init은 주기적으로 wait()을 호출

## 3.4 프로세스 간 통신 ( IPC )
OS 내에서 실행되는 병행 프로세스들은 독립적이거나 협력적인 프로세스이다.
* 독립적 : 프로세스가 시스템에서 실행중인 다른 프로세스들과 데이터를 공유하지 않음
* 협력적 : 프로세스가 시스템에서 실행 중인 다른 프로세스들에 영향을 주거나 받음

프로세스 협력을 허용하는 이유
1. 정보 공유
2. 계산 가속화
3. 모듈성 : 큰 부분 하나가 아니라, 작은 부분 여러 개로 나누어서 유연성 + 효율성 증가

 





 
