# 3장 프로세스

- - -
## 이 장의 목표
* 프로세스의 개별 구성요소를 식별하고 OS에서 해당 구성요소가 어떻게 표현되고 스케쥴되는지 기술
* OS에서 proc을 생성/종료하는 방법을 설명
* 공유 메모리 및 메시지 전달을 사용하는 IPC 통신을 설명하고 대조
* 파이프와 POSIX 공유 메모리를 사용하여 IPC를 수행하는 수행하는 프로그램을 설계
* 소켓과 원격 프로시져 호출을 사용하여 클라이언트-서버 통신을 설명
* Linux OS와 상호작용하는 kernel 모듈을 설계

- - -

## 3.1 프로세스 개념
OS를 논의할 떄 한가지 문제점이, 모든 CPU 활동들을 어떻게 부를 것인가에 대한 의문이었다.
초창기에는 job을 실행하는 일괄처리 시스템이었고, 사용자 프로그램 또는 task를 실행하는 시분할 시스템이 뒤를 이었다.
이제는 여러 프로그램을 한번에 실행할 수 있고 다중 태스킹을 지원하지 않는 ES 장치에서와 같은 곳에서도 OS는 
메모리 관리와 같은 자체 프로그램된 내부 활동을 지원해야 할 수도 있다.
따라서 이러한 모든 활동은 process라고 부를 수 있다.

 ### 3.1.1. 프로세스
 프로세스는 실행중인 프로그램이다. ( 프로그램 != 프로세스 )
 proc의 현재 활동 상태는 PC(다음에 실행할 명령어) + register의 내용으로 나타난다.

 <img width="184" alt="3장_1" src="https://github.com/dbswns124/OS-/assets/149889867/1219ffaf-9d6a-42dd-a4ea-6e70fddb2143">

proc의 메모리 내에서의 배치는 위와 같은 모양이다.
* 텍스트 : 실행 코드
* 데이터 섹션 : 전역 변수 ( C에서는 또다시 초기화 된 부분 / 초기화 되지 않은 부분 ( bss) 로 나뉜다 )
* 힙 : 프로그램 실행중에 동적으로 할당되는 메모리, 위로 자람
* 스택 : 함수를 호출할 때 임시 데이터 저장소, 아래로 자람 ( 함수 매개변수, 복귀 주소, 지역 변수 다 여기있음)

텍스트, 데이터 섹션의 크기는 불변이고, 힙과 스택은 가변적이다.

### 3.1.2 프로세스 상태 

<img width="377" alt="3장_2" src="https://github.com/dbswns124/OS-/assets/149889867/182856bc-99ef-40a6-90b2-6daec19918ce">
 
프로세스 상태 : 5 state ( 실행되면서 상태가 이 안에서 변함 )
new / running / waiting / ready / terminated
new proc은 ready queue로 감
프로세스는 실행을 위해 선택되거나 dispatch될 때까지 기다림
이름은 임의적이고, OS마다 다름, 하지만 모든 시스템에서 이 상태에 해당되는 단계들이 있음

### 3.1.3 프로세스 제어 블록 ( PCB )

각 프로세스는 PCB에 의해 표현된다.
특정 proc과 관련된 여러가지 정보들을 수록하며, 다음과 같은 정보들을 저장
process state(5 state)
PC : program counter, 다음에 실행할 명령어의 주소
CPU 레지스터들안의 값들
CPU 스케쥴링 정보 ( 우선순위, 스케쥴 큐에 대한 포인터 + 다른 스케쥴 매개변수들 )
메모리 관리정보(9장 참조)
회계정보 ( CPU 사용시간 + 경과된 실시간, 시간제한 .job/proc num도 포함됨)
입출력 상태정보 : 이 proc에 할당된 입출력 장치들과 열린파일 목록들(open file table)


### 3.1.4 스레드 ( threads )
이제까지 논의한 프로세스 모델은 프로세스가 단일 실행 스레드만 가능 == 한개의 논리적 흐름을 갖고 있음
대부분의 현대 OS는 프로세스 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용
따라서 한 프로세스의 여러 스레드가 병렬로 수행될 수 있게 된다.

## 3.2 프로세스 스케쥴링

멀티 프로그래밍 : CPU 이용률을 최대화 하는것에 목표가 있음, 따라서 메모리에 여러가지 프로그램을 올려서 그중 하나의 프로그램을 실행하는 것
이렇게 되면 여러 프로그램중에서 어느것을 실행해야 할지 결정해야 한다 -> 프로세스 스케쥴링이 필요해짐

### 3.2.1 스케쥴링 큐
프로세스가 시스템에 들어가면 ready queue에 들어가서 CPU 코어에서 실행되기를 기다리고, 일반적으로는 연결 리스트로 저장된다.

### 3.2.2 CPU 스케쥴링
프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 옮겨 다닌다.
**CPU 스케쥴러**의 역할은 준비 큐에 있는 proc중 선택된 하나의 proc에 CPU 코어를 할당하는 것이다.
( 일부 OS는 스와핑이라는 중간 형태의 스케쥴링을 이용, swap-in,out을 통해 다중 프로그래밍 정도를 낮춤 )

### 3.2.3 문맥 교환 ( context switch )
더이상 프로세스를 진행할 수 없어서 wait상태로 가거나, 인터럽트가 발생한 경우 등등에는 문맥을 저장하고 대기 상태로 간 후에 이벤트가 처리된 후에 재개 되어야 된다.
이 문맥은 PCB에 저장되고, 해댱되는 값은 레지스터 값, 프로세스 상태, 메모리 관리 정보 등을 포함한다.
CPU 코어를 다른 프로세스로 교환하려면
1. 현재 process의 정보를 PCB에 저장
2. 스케쥴링 알고리즘 돌려서 ready queue에서 한개의 process를 선택
3. 해당 process의 PCB에서 정보들을 덮어 씀
context switch동안에는 CPU가 유용한 일을 하지 못하기 때문에 이 시간은 순수한 오버헤드이다.

## 3.3 프로세스에 대한 연산
대부분 시스템 내의 프로세스들은 concurrent하게 실행될 수 있으며, 반드시 동적으로 생성되고 제거되어야 함

### 3.3.1 프로세스 생성
실행되는 동안 프로세스는 여러 개의 새로운 프로세스들을 생성할 수 있음 ( 리눅스에서는 fork() )
생성하는 proc = 부모 프로세스, 생성된 proc = 자식 프로세스
그리고 생성된 후에는 두가지 중에 한가지 형태를 보인다
1. 부모와 자식이 병행하게 실행을 계속
2. 부모는 일부 또는 모든 자식이 실행을 종료할 때 까지 기다린다.
따라서 시스템은 프로레스 트리를 형성할 수 있다.
대부분의 현대 OS는 **유일한** 프로세스 식별자(pid)를 사용하여 프로세스를 구분하는데, 이 식별자는 보통 정수다.

### 3.3.2 프로세스 종료
프로세스가 마지막 문장의 실행을 끝내고 exit() 시스템 콜을 사용하여 OS에 자신의 삭제를 요청하면 종료된다.
이 시점에서 프로세스는 자신을 기다리고 있는 부모 프로세스에 종료상태값을 반환할 수 있다.
종료시에는 갖고있던 모든 자원이 할당 해제되고 OS로 반납된다
아니면 한 프로세스는 다른 프로세스에 의해 종료될 수도 있다. ( kill(pid)를 통해 )

> 좀비 프로세스 : 종료되었지만, 부모 프로세스가 아직 wiat() 호출을 하지 않은 프로세스
>              -> 종료 상태가 저장되는 프로세스 테이블의 항목은 남아있게 됨
> 고아 프로세스 : 부모 프로세스가 wait()을 호출하는 대신 종료하면 이 상황에 부닥친 프로세스를 고아 프로세스                 라고 함
> 전통적인 INIX는 고아 프로세스의 새로운 프로세스를 init 프로세스로 지정 + init은 주기적으로 wait()을 호출

## 3.4 프로세스 간 통신 ( IPC )
OS 내에서 실행되는 병행 프로세스들은 독립적이거나 협력적인 프로세스이다.
* 독립적 : 프로세스가 시스템에서 실행중인 다른 프로세스들과 데이터를 공유하지 않음
* 협력적 : 프로세스가 시스템에서 실행 중인 다른 프로세스들에 영향을 주거나 받음

프로세스 협력을 허용하는 이유
1. 정보 공유
2. 계산 가속화
3. 모듈성 : 큰 부분 하나가 아니라, 작은 부분 여러 개로 나누어서 유연성 + 효율성 증가


## 3.5 공유 메모리 시스템에서의 프로세스 간 통신
공유 메모리를 사용하는 프로세스 간 통신에서는 통신하는 프로세스들이 공유 메모리 영역을 구축해야 한다.
일반적으로 OS는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 금지한다. 따라서 공유 메모리는 둘 이상의 프로세스가 이 제약 조건을 제거하는 것에 동의하는 것을 필요로 한다.
협력하는 프로세스의 개념을 잘 이해하기 위해서, 협력하는 프로세스의 일반적인 패러다임인 생산자-소비자 문제를 이해하면 된다.
생산자 : 정보를 생산
소비자 : 정보를 소비
생각해볼수 있는 예시

- - - 
## 리눅스에서 공유 메모리를 이용한 실습
fork를 통해 메모리 공간을 공유하게 하고, pid를 통해서 부모와 자식을 구별한 후에
부모 = 소비자, 자식이 정보를 생산하기를 기다림, 버퍼에 메모리가 채워졌음은 자식이 죽어서 데이터를 보냄
자식 = 생산자, 정보를 생산한 후에 죽으면 됨
이렇게 했을 때의 결과
fork()를 해서 복사해서 사용 != 같은 공간을 공유, 따라서 원하는 값이 나오지 않음

<img width="209" alt="3장_3" src="https://github.com/dbswns124/OS-/assets/149889867/4210b792-f3ed-4169-a6e8-79019f5d1ff3">

<img width="307" alt="3장_4" src="https://github.com/dbswns124/OS-/assets/149889867/1e0f089b-1d7a-404d-bb09-d3260cb6a6ae">

따라서 IPC object를 만들고, 그를 통해 통신해야 함
SHM : 프로세스 사이에 공유할 수 있는 메모리를 지정하는 기법
IPC 형태중 가장 빠른 방법 ( data의 복사가필요하지 않음 )

<img width="464" alt="3장_5" src="https://github.com/dbswns124/OS-/assets/149889867/e408af99-b3af-42ad-bc5f-75004cad00b9">

* 필요한 lib : <sys/types.h>, <sys/ipc.h>, <sys/shm.h>
* int shmget(key_t key, size_t size, int flag)
  -> 리턴값 : shm의 identifier, key : SHM을 구별하는 키값, 사이즈 : 메모리 영역의 최소 크기, flag : 옵션       지정
* void *shmat(int shmid, const void *addr, int flag)
  -> 리턴값 : shm 시작주소, shmid : shmget함수로 생성한 shm의 ientifier, addr : 공유 메모리를 연결할 주
* void shmdt(void* addr)
  -> 리턴값 : 0이면정상, -1이면 에러, addr : 연결 해제할 shm의 시작주소 ( == shmat의 리턴값 ) 

위 자료구조와 함수를 이용한 코드와 결과

<img width="335" alt="3장_6" src="https://github.com/dbswns124/OS-/assets/149889867/da5ba517-c6b1-4dd3-8324-b5668995aec4">
<img width="318" alt="3장_7" src="https://github.com/dbswns124/OS-/assets/149889867/0b568060-b994-48a0-83da-8160bde99915">
<img width="269" alt="3장_8" src="https://github.com/dbswns124/OS-/assets/149889867/51826a5b-59ca-4465-b0da-3e43e9b7d60d">

정상 작동 했고, shmat과 shmdt후에도 메모리상의 위치는 변하지 않음을 확인할 수 있다.

- - - 

## 3.6 메시지 전달 시스템에서의 프로세스 간 통신
다른 IPC 기법으로는 OS가 메시지 전달 설비를 통하여 서로 협력하는 프로세스 간의 통신 수단을 제공해 주는 방법도 있다.
메시지 전달 방식은 동일한 주소 공간을 사용하지 않고도 프로세스들이 통신을 하고, 그들의 동작을 동기화할 수 있도록 허용하는 기법을 제공한다.
메시지 전달 시스템은 최소한 send(message), receive(message) 두가지 연산은 제공한다.
이 방법을 이용하려는 두 프로세스 P,Q가 있다고 생각하자. 이 둘이 메시지를 주고 받으려면 
이들 사이에 **통신연결**이 설정되어야 한다. 그리고 이 연결은 다양한 방법으로 구현할 수 있다
구현된 하나의 링크와 send/receive연산을 논리저으로 구현하는 방법은 다음과 같다
* 직접 / 간접
* 동기식 / 비동기식
* 자동 / 명시적 버퍼링

### 3.6.1 명명 ( naming )
통신을 원하는 프로세스들은 서로를 가리킬 방법이 있어야 한다. 이들은 간접 통신 또는 직접 통신을 이용할 수 있다
직접 통신에서는 각 프로세스는 상대방의 이름을 명시해야 한다.
그렇게 되면 
send(P,msg), receive(Q,msg) 형태의 함수로 쓸 수 있다.
따라서 직접 통신은 다음과 같은 특성을 가진다.
+ 통신을 원하는 각 프로세스들 쌍들 사이에 연결이 자동으로 구축된다. 프로세스들은 통신하기 위해 상대방의 신원(identitiy)만 알면 된다.
+ 연결은 **정확히 두 프로세스 사이**에만 연관된다.
+ 통신하는 프로세스들의 각 쌍 사이에는 정확하게 하나의 연결이 존재해야 한다
이 특성들은 직접 연결이니까...당연한 듯 싶다.
이 기법은 주소 방식에서 *대칭성*을 보이는데, 이 기법의 변형으로 *비대칭*을 사용할 수도 있다.
(송신자만 수신자 이름을 지명 수신자는 pid를 통해 수신받음 )
이 기법은 모두 프로세스를 지정해야 함 -> 모듈성을 제한한다는 것이 단점

> 모듈성 :  컴퓨터 프로그램이 모듈이라고 부르는 분리된 부분으로 작성될 때 나타나는 특성

간접 통신에서 메시지들은 메일박스, 또는 포트로 송/수신된다.
이런 경우에는 
send(A(mbox),msg), receive(A,msg)로 함수들을 쓸 수 있다
따라서 간접통신은, 직접통신과 다르게 두개 이상의 프로세스들과 연관될 수 있다.

### 3.6.2 동기화 ( synchronization )
프로세스간 통신은 send, receive 함수에 대한 호출에 의해 발생된다.
각 함수를 구현할 떄는 다른 설계 옵션이 있다
* 봉쇄형 ( blocking ) == 동기식
* 비봉쇄형 ( nonblocking ) == 비동기식

### 3.6.3 버퍼링
통신이 직접적이든, 간접적이든 간에 통신하는 프로세스들에 의해 교환되는 메시지는 임시 큐에 들어가있다.
기본적으로 이러한 큐를 구현하는 방식에는 세 가지가 있다.
* 무용량 : 큐의 최대 길이가 0, 송신자는 수신자가 메시지를 수신할 때까지 기다려야 함
* 유한 용량 : bounded capacity, 큐에 n개의 메시지를 놓을 수 있고, 꽉 차지 않은 상태면 계속 생산해서 수신 가능, 꽉 차있으면 수신자가 수신할 때까지 기다려야 함
* 무한 용량 : 잠재적으로 무한한 길이를 가짐 -> 송신자는 절대 봉쇄되지 않음

- - - 
## Message queue의 예시 ( 리눅스 )
key는 IPC 생성할 떄 주는 값
key를 생성하는 법
1. 사용자 지정 -> 유니크하지 않을 가능성 높음
2. ftok -> 시스템에 요청, **만의 하나**의 확률로 유니크하지 않을 수 있음
3.  IPC_PRIVATE 상수를 key_t key에 넣어주면 kernal이 key값을 하나 대응시켜줌
(시스템에서 사용되고 있지 않은 것중에 하나를 줌 --> 유니크함을 보장해줌 )

shared memory와 마찬가지로, send, receive를 위해서 먼저 자료구조를 만들어야 한다.
key를 생성하는 방법중에 1번을 사용 ( 예시에 오류가 없게 하기 위해서, ipcs -q를 확인해서 해당 dir에 생성된 msq 자료구조가 없음을 확인하고 수행했다 )

















  




 
