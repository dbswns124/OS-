# 파일 시스템 인터페이스

## 이 장의 목표
* 파일 시스템의 기능을 설명
* 파일 시스템 인터페이스의 특징을 기술
* 접근 방법, 파일 공유, 파일 락, 디렉터리 구조를 포함하는 파일 시스템 설계 절충에 관하여 논의
* 파일 시스템 보호에 대해서 고려해보기


## 13.1 파일 개념 ( file concept )
컴퓨터는 정보를 NVM,HDD,자기 디스크 등등 각기 다른 저장 매채에 저장 가능
OS는 컴퓨터 시스템을 편리하게 사용하기 위해 저장된 정보에 대한 일관된 논리적 관점을 제공하고 저장장치의 
물리적 특성을 추상화하여 논리적 저장단위, 즉 **파일** 을 정의한다.
따라서 파일은 보조저장장치에 기록된 관련 정보들의 집합이라고 정의할 수 있다
그리고 파일은 일반적으로 프로그램(소스 프로그램, 목적 프로그램)과 자료를 나타낸다
* 자료 파일 : 숫자, 문자 또는 이진수로 구성되고 형식은 자유로울 수도, 엄격할 수도 있음
* 소스 파일 : 함수들의 연속이고 각 함수는 선언과 실행문의 순서로 구성됨
* 실행 파일 : loader가 memory로 가져와 실행시킬 수 있는 연속된 코드 부분들
* 텍스트 파일 : 행들로 구성되는 연속적인 문자들

### 13.1.1 파일 속성 ( file attributes )
사용자는 편의를 위해 파일에 이름을 부여하고, 그 이름으로 파일을 참조한다
파일은 OS마다 다른 속성을 가지지만, 전형적으로는 **이름 식별자 유형 위치 크기 보호** 정도의 속성을 가진다

### 13.1.2 파일 연산 ( file operations )
파일은 추상적인 데이터 유형이므로, 적절히 정의하기 위해서는 파일에 대한 연산을 고려해 볼 필요가 있다.
OS가 제공하는 시스템 콜들
* 파일 생성 : 파일을 저장할 수 있는 공간을 찾기 + 새로 생성될 파일에 대한 항목이 directory에 만들어져야 함
* 파일 열기 : open()을 통해서 다른 콜에 사용되는 파일 핸들을 반환
* 파일 쓰기 : 파일 쓰기 위해서는 파일 핸들과 시스템 콜이 필요, 어디에 쓸지를 가리키는 쓰기 포인터를 시스템이 유지
* 파일 읽기 : 파일핸들 + 읽혀야 할 블록위치가 인자로 주어지는 시스템콜을 이용,
              쓰기와 마찬가지로 읽기 포인터를 시스템이 유지해야 함
* 파일 안에서의 위치 재설정 : seek()
* 파일 삭제 : 지정된 파일을 dir에서 찾고, 찾으면 다른 파일이 재사용 할 수 있도록 모든 파일 공간을 해제

> **하드 링크** : 동일한 파일에 대해 여러 개의 이름이 존재할 수 있게 해줌
> 리눅스에서는 여러개의 file_name이 한개의 inode를 가리키게 하는 것

* 파일 절단 : 파일의 내용은 지우고 속성은 그대로 남기기를 원할 때 사용

위의 7개의 연산은 파일 조작에 필요한 최소 연산이다.
대부분의 파일 연산들은 먼저 파일을 찾는 작업을 해야 하는데, 반복 탐색을 피하려면 open()시스템 콜을 통해 핸들을
받아오면 된다.
또한, OS는 모든 열린 파일에 대한 정보를 ***open-file table***을 유지한다, 여기에는 open count도 있음
어떤 process가 open()을 해서 열리면 cnt++되고, close되면 --, 0이 되면 더이상 사용되지 않음을 의미하므로
open-file tbl에서 해당 idx를 제거한다.
임의의 파일 연산이 요구되면, 이 테이블에 대한 idx로 그 파일을 지정하므로 어떠한 탐색도 필요하지 않음
> 열린 파일과 관련된 정보
> 1. 파일 포인터  :가장 최근의 읽기/쓰기를 추적해서 다음에 어디서 읽고 쓸지 알기 위해 유지
> 2. 파일 열린 계수어떤 process가 open()을 해서 열리면 cnt++되고, close되면 --, 0이 되면 더이상 사용되지 않음을 의미하므로
      open-file tbl에서 해당 idx를 제거한다.
> 3. 파일의 위치
> 4. 접근 권한 : OS는 이 권한을 통해 후속 요구를 허용/거절하는데 사용

### 13.1.3 파일 유형
OS가 파일 유형을 지우너하면, OS는 파일에 대해 합리적인 연산을 수행할 수 있다.
흔히 잘 알려진 방식은 파일이름.파일 유형 ( ex : consoleapp1.cpp -> C++ 파일, main.c -> C 소스코드 파일 )

### 13.1.4 파일 구조
파일의 유형을 사용하여 파일의 내부 구조 형태를 짐작할 수 있다
각각의 파일들은 그 파일을 다루는 프로그램에 의해 인식 가능한 내부 구조를 일정한 형태로 가지게 된다

##### 하지만, OS가 여러 파일 구조를 지원하는 경우에는 OS의 크기가 커지고 관리하기 어려워 진다는 점이다.
UNIX, windows는 파일의 형태, 구조에 관하여 제한을 두지 않음
-> 시스템은 어떠한 목적으로도 자유롭게 파일을 사용할 수 있고, 유연성은 극대화 된다.
   그 대신 시스템 차원에서의 파일 유형 지원은 상대적으로 적다
+ 모든 파일은 반드시 프로그램을 로딩하고 실행할 수 있는 **실행 파일**의 구조는 반드시 지원해야 한다.

## 13.2 접근 방법
파일은 정보를 저장하므로, 파일이 사용되는 것 == 정보가 접근되어 컴퓨터 메모리로 읽혀야 함
접근 방법은 여러가지가 있을 수 있고, 특정 응용 프로그램에 적합한 것을 선택하는 것이 주요 설계 문제이다.

### 13.2.1 순차 접근 ( sequential Access )
가장 간단한 접근 방법인 순차 접근이다.
읽기는 파일의 다음 부분부터 읽어 나가고, 읽으면 현재 위치를 추적하는 파일 포인터인 offset이 자동으로
증가한다. 마찬가지로 쓰기 작업은 파일 끝에 추가하며 새로운 파일의 끝으로 offset이 이동, 이 offset을 
맨 앞이나 맨 뒤로 옮겨서 사용할 수 있다.

### 13.2.2 직접 접근 ( direct Access )
파일은 고정 길이의 logical record의 집합으로 정의되고, 이 직접 접근은 어떤 블록이라도 직접 엑세스할 수 있다.
직접 접근을 위해서는 파일은 번호를 갖는 일련의 블록 또는 레코드로 간주한다.
대규모의 정보를 다루는 데 아주 유용하며 대규모 DB가 이런 유형일 수 있다
(어떤 query가 들어오면 그 답을 수록하고 있는 블록을 체크하고 query에 적합하면 정보를 읽는 것 )

### 13.2.3 기타 접근 방법
직접 접근 파일이 있으면 그것을 기반으로 여러 가지 다른 파일 접근 방법을 제공할 수 있다. 대부분 index를 사

## 13.3 디렉터리 구조 
디렉터리(앞으론 dir)은 파일 이름을 상응하는 파일 제어 블록으로 바꾸어 주는 symbol table이라고 볼 수 있다.











