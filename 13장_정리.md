# 파일 시스템 인터페이스

## 이 장의 목표
* 파일 시스템의 기능을 설명
* 파일 시스템 인터페이스의 특징을 기술
* 접근 방법, 파일 공유, 파일 락, 디렉터리 구조를 포함하는 파일 시스템 설계 절충에 관하여 논의
* 파일 시스템 보호에 대해서 고려해보기


## 13.1 파일 개념 ( file concept )
컴퓨터는 정보를 NVM,HDD,자기 디스크 등등 각기 다른 저장 매채에 저장 가능
OS는 컴퓨터 시스템을 편리하게 사용하기 위해 저장된 정보에 대한 일관된 논리적 관점을 제공하고 저장장치의 
물리적 특성을 추상화하여 논리적 저장단위, 즉 **파일** 을 정의한다.
따라서 파일은 보조저장장치에 기록된 관련 정보들의 집합이라고 정의할 수 있다
그리고 파일은 일반적으로 프로그램(소스 프로그램, 목적 프로그램)과 자료를 나타낸다
* 자료 파일 : 숫자, 문자 또는 이진수로 구성되고 형식은 자유로울 수도, 엄격할 수도 있음
* 소스 파일 : 함수들의 연속이고 각 함수는 선언과 실행문의 순서로 구성됨
* 실행 파일 : loader가 memory로 가져와 실행시킬 수 있는 연속된 코드 부분들
* 텍스트 파일 : 행들로 구성되는 연속적인 문자들

### 13.1.1 파일 속성 ( file attributes )
사용자는 편의를 위해 파일에 이름을 부여하고, 그 이름으로 파일을 참조한다
파일은 OS마다 다른 속성을 가지지만, 전형적으로는 **이름 식별자 유형 위치 크기 보호** 정도의 속성을 가진다

### 13.1.2 파일 연산 ( file operations )
파일은 추상적인 데이터 유형이므로, 적절히 정의하기 위해서는 파일에 대한 연산을 고려해 볼 필요가 있다.
OS가 제공하는 시스템 콜들
* 파일 생성 : 파일을 저장할 수 있는 공간을 찾기 + 새로 생성될 파일에 대한 항목이 directory에 만들어져야 함
* 파일 열기 : open()을 통해서 다른 콜에 사용되는 파일 핸들을 반환
* 파일 쓰기 : 파일 쓰기 위해서는 파일 핸들과 시스템 콜이 필요, 어디에 쓸지를 가리키는 쓰기 포인터를 시스템이 유지
* 파일 읽기 : 파일핸들 + 읽혀야 할 블록위치가 인자로 주어지는 시스템콜을 이용,
              쓰기와 마찬가지로 읽기 포인터를 시스템이 유지해야 함
* 파일 안에서의 위치 재설정 : seek()
* 파일 삭제 : 지정된 파일을 dir에서 찾고, 찾으면 다른 파일이 재사용 할 수 있도록 모든 파일 공간을 해제

> **하드 링크** : 동일한 파일에 대해 여러 개의 이름이 존재할 수 있게 해줌
> 리눅스에서는 여러개의 file_name이 한개의 inode를 가리키게 하는 것

* 파일 절단 : 파일의 내용은 지우고 속성은 그대로 남기기를 원할 때 사용

위의 7개의 연산은 파일 조작에 필요한 최소 연산이다.
대부분의 파일 연산들은 먼저 파일을 찾는 작업을 해야 하는데, 반복 탐색을 피하려면 open()시스템 콜을 통해 핸들을
받아오면 된다.
또한, OS는 모든 열린 파일에 대한 정보를 ***open-file table***을 유지한다, 여기에는 open count도 있음
어떤 process가 open()을 해서 열리면 cnt++되고, close되면 --, 0이 되면 더이상 사용되지 않음을 의미하므로
open-file tbl에서 해당 idx를 제거한다.
임의의 파일 연산이 요구되면, 이 테이블에 대한 idx로 그 파일을 지정하므로 어떠한 탐색도 필요하지 않음
> 열린 파일과 관련된 정보
> 1. 파일 포인터  :가장 최근의 읽기/쓰기를 추적해서 다음에 어디서 읽고 쓸지 알기 위해 유지
> 2. 파일 열린 계수어떤 process가 open()을 해서 열리면 cnt++되고, close되면 --, 0이 되면 더이상 사용되지 않음을 의미하므로
      open-file tbl에서 해당 idx를 제거한다.
> 3. 파일의 위치
> 4. 접근 권한 : OS는 이 권한을 통해 후속 요구를 허용/거절하는데 사용

### 13.1.3 파일 유형
OS가 파일 유형을 지원하면, OS는 파일에 대해 합리적인 연산을 수행할 수 있다.
흔히 잘 알려진 방식은 파일이름.파일 유형 ( ex : consoleapp1.cpp -> C++ 파일, main.c -> C 소스코드 파일 )

### 13.1.4 파일 구조
파일의 유형을 사용하여 파일의 내부 구조 형태를 짐작할 수 있다
각각의 파일들은 그 파일을 다루는 프로그램에 의해 인식 가능한 내부 구조를 일정한 형태로 가지게 된다

##### 하지만, OS가 여러 파일 구조를 지원하는 경우에는 OS의 크기가 커지고 관리하기 어려워 진다는 점이다.
UNIX, windows는 파일의 형태, 구조에 관하여 제한을 두지 않음
-> 시스템은 어떠한 목적으로도 자유롭게 파일을 사용할 수 있고, 유연성은 극대화 된다.
   그 대신 시스템 차원에서의 파일 유형 지원은 상대적으로 적다
+ 모든 파일은 반드시 프로그램을 로딩하고 실행할 수 있는 **실행 파일**의 구조는 반드시 지원해야 한다.

## 13.2 접근 방법
파일은 정보를 저장하므로, 파일이 사용되는 것 == 정보가 접근되어 컴퓨터 메모리로 읽혀야 함
접근 방법은 여러가지가 있을 수 있고, 특정 응용 프로그램에 적합한 것을 선택하는 것이 주요 설계 문제이다.

### 13.2.1 순차 접근 ( sequential Access )
가장 간단한 접근 방법인 순차 접근이다.
읽기는 파일의 다음 부분부터 읽어 나가고, 읽으면 현재 위치를 추적하는 파일 포인터인 offset이 자동으로
증가한다. 마찬가지로 쓰기 작업은 파일 끝에 추가하며 새로운 파일의 끝으로 offset이 이동, 이 offset을 
맨 앞이나 맨 뒤로 옮겨서 사용할 수 있다.

### 13.2.2 직접 접근 ( direct Access )
파일은 고정 길이의 logical record의 집합으로 정의되고, 이 직접 접근은 어떤 블록이라도 직접 엑세스할 수 있다.
직접 접근을 위해서는 파일은 번호를 갖는 일련의 블록 또는 레코드로 간주한다.
대규모의 정보를 다루는 데 아주 유용하며 대규모 DB가 이런 유형일 수 있다
(어떤 query가 들어오면 그 답을 수록하고 있는 블록을 체크하고 query에 적합하면 정보를 읽는 것 )

### 13.2.3 기타 접근 방법
직접 접근 파일이 있으면 그것을 기반으로 여러 가지 다른 파일 접근 방법을 제공할 수 있다. 대부분 index를 사용

## 13.3 디렉터리 구조 
디렉터리(앞으론 dir)은 파일 이름을 상응하는 파일 제어 블록으로 바꾸어 주는 symbol table이라고 볼 수 있다.
따라서 디렉터리 그 자체가 여러가지 방법으로 구성될 수 있다. 이 절에서는 디렉터리 시스템의 논리적 구조를 정의하는 몇몇 체계를 일아본다

특정한 dir 구조를 고려할 떄, 각 dir에 수행될 수 있는 연산을 주의깊게 살펴보아야 한다. 
* dir 연산들
*  파일찾기 : 사용자는 특정 파일을 찾기 위해 dir을 탐색할 필요가 있다.
*  파일 삭제 : 더는 필요하지 않은 파일을 dir에서 삭제
*  dir 나열 : 디렉터리에 존재하는 파일을 나열하고, 파일에 대한 dir 항목의 내용을 보여준다.
*  파일의 재명명 : 파일의 이름을변경
*  파일 시스템의 순회 : 파일 시스템의 여러 dir을 순회해 다니며 파일을 볼 수 있게 해주는 기능은 매우 유용하다.

-----
## 리눅스에서 파일 연산 + dir 안에서의 연산에 대한 실습
- - -

### 13.3.1 1단게 dir
가장 간단한 dir 구조는 1단계 dir이다.
여기서는 모든 파일이 다 같이 한개의 dir 밑에 있으므로 개념은 간단하다.
하지만, 파일이 많아지거나 다수의 사용자가 사용하는 시스템에서는 심각한 제약을 갖고 있다.
각 파일의 이름이 유일해야 하는데, 매번 다른 이름으로 명명하고 기억하기 쉽지 않음
<img width="382" alt="1" src="https://github.com/dbswns124/OS-/assets/149889867/26cc23bc-073c-4c0e-a637-334f95e15a9e">

### 13.3.2 2단계 dir
1단계 dir에 대한 해결책으로 각 사용자에게 서로 다른 dir을 만들어주는게 2단계 dir이다.
각 user는 자신만의 dir ( user file directory, UFD )를 갖고, UFD는 비슷한 구조로 되어있지만 각 dir에는 오직 한 사람만 파일을 저장.
-> 마스터 파일 dir ( MFD ) 아래에 여러가지 UFD가 있는 구조
<img width="422" alt="2" src="https://github.com/dbswns124/OS-/assets/149889867/0a86138e-a3df-48cf-a941-e84f541e9933">

이 구조에서는 한 사용자의 UFD를 다른 사용자가 접근할수 없게 되어서, 공유 할 수 없게 됨
접근할 수 있게 되면, path를 명확히 제시해야 함


### 13.3.3 트리 구조 dir
2단계 디렉터리 구조를 여러 단계로 확장한 구조
<img width="358" alt="3" src="https://github.com/dbswns124/OS-/assets/149889867/7ccae20a-3830-4394-b779-bf94a9a19ce4">

dir은 내부에 dir, 파일을 가질 수 있음
통상적으로 각 프로세스는 현재 dir ( current dir ) 을 가지고 있다.
경로명에는 두가지가 있다.
1. 절대 경로명 : absolute path name, root부터 파일까지 경로를 모두 적는것
2. 상대 경로명 : relative path name, 현재 dir을 이용해서 경로를 정의하는 것

트리구조에서 생기는 흥미로운 문제는 dir의 삭제 문제이다.
dir이 비어있으면 간단하지만, 비어있지 않으면 전부 삭제 / 삭제하지 않기 ( Linux에서는 rm에 옵션을 통해 선택)

### 13.3.4 비순환 그래프 dir
트리구조는 dir이나 파일의 공유를 허락하지는 않지만, 비순환 그래프는 dir이 서브dir,파일들을 공유할 수 있도록 허용하는 구조이다. ( 복사본과는 다름!! )
<img width="344" alt="4" src="https://github.com/dbswns124/OS-/assets/149889867/d90ad603-b512-4748-bcd7-7db4ed914861">
공유 파일,dir은 여러가지 방법으로 구현된다.
일반적인 방법은 link라고 불리는 새로운 dir항목을 만드는 것이다.
*link : 다른 파일이나 sub_dir을 가리키는 포인터, 절대/상대 경로명으로 구현될 수 있음
또 다른 방법은 dir들이 동일한 항목 내용을 복사해서 가지고 있는 방법이다.
따라서 하나의 dir/파일을 변경하면 다른 동일한 복사본들도 바뀌어야 하는 일관성 문제가 있다.

비순환 그래프 dir은 트리 구조보다 융퉁성이 있고 더 복잡하다.
고려해야될 문제점이 많다.
1. 여러개의 절대 경로를 갖지 않게 해야함
2. 삭제 시의 문제

### 13.3.5 일반 그래프 dir
비순환 그래프 dir에서 중요한 문제점은 순환이 발생하지 않도록 어떻게 보장하냐는 것이다.
2단계 dir 구조에서 시작해서 사용자가 subdir을 생성하면 트리 구조가 형성된다.
단순히 새로운 파일/dir의 추가는 기존 트리구조의 성질을 유지하지만, 새로운 링크를 추가하면 트리구조는 파괴되고 일반적인 그래프 구조가 될 수 있다.

<img width="371" alt="5" src="https://github.com/dbswns124/OS-/assets/149889867/233f60d6-8043-406b-a8e3-0ad058b1fdcf">

비순환 그래프의 장점 : 파일 검색, 파일에 대한 참조의 존재 여부를 결정하는 알고리즘이 비교적 간단함
순환이 허용될 경우, 잘못 설계된 알고리즘에서는 탐색을 종료하지 못하고 무한루프에 빠질 수 있게 됨
이러함 문제는 파일을 삭제할 경우에도 발생한다. 





